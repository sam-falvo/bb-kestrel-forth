    .p816
    .a16
    .i16


    .include "hw/cpu.inc"
    .include "hw/chipset.inc"


;
; Emulates a dumb teletype.
;
; Footnote:
; It amazes me that we are still emulating -teletypes-.  Commodore has gone
; the furthest in advancing the state of the art in textual user interfaces
; by implementing a crude text editor as their basic UI.  At some point in
; the future, I will revisit this idea; it's what I strove for in the orig-
; inal Kestrel-2 ROMs, but never fully realized.
;
; Some day...
;


    .rodata

romFont:
    .incbin "font.bin"


    .bss

    ; Keyboard scancode last detected
lastKeyPressed:
        .res 2

    ; Number of raw keyboard events since last tioGetKey
rawKeyEvents:
        .res 2

    ; The current (x,y) cursor position.
cx:     .res 2      ; invariant: 0 <= x < right
cy:     .res 2      ; invariant: 0 <= y < bottom

    ; Non-zero if the cursor is obscured from the screen.
hidden: .res 2      ; invariant: 0 <= hidden <= 65535

    ; Non-zero if the cursor is physically rendered to the screen.
    ; This is distinct from the cursor hiddenness, because the cursor
    ; may be visible but not drawn at the current moment (it's a
    ; blinking cursor).
cursorIsDrawn: .res 2


RIGHT   = 80
BOTTOM  = 60

    ; pointer to a 2048x8 pixel bitmap containing the font to draw with.
    ; All glyphs are 8x8 pixels in size.
_font:  .res 4


    .code

.export tioInitialize
.proc tioInitialize
    pha

    ; initialize the MGIA chip for rendering a VGA-standard image.

    lda #800
    sta CCHZTL
    lda #525
    sta CCVRTL
    lda #$025F
    sta CCSYWD

    ; set the display to the (hopefully) center of the view'ers monitor.

    lda #140
    sta VIHZST
    lda #780
    sta VIHZEN
    lda #34
    sta VIVRST
    lda #514
    sta VIVREN
    inc
    sta CCVRLI

    ; initialize cursor position, display font, and other details.

    stz cx
    stz cy
    stz hidden
    lda #romFont
    sta _font
    stz _font+2
    pla
    rts
.endproc


.export tioTypeCharacter
.proc tioTypeCharacter
    jsr tioHideCursor
    jsr i_TypeCharacter
    jmp tioShowCursor
.endproc
.proc i_TypeCharacter
    ; Prints a single character to the screen.
    ;
    ; Preconditions:
    ;   A[7:0] = character to plot
    ;   A[15:8] ignored.
    ;
    ;   Framebuffer established using _wide, _setFramebuffer, et. al.
    ;   Cursor window established: see _setWindowOrigin, _setWindowExtent.
    ;   Cursor position previously established; see _setXY.
    ;
    ; Post-conditions:
    ;   A, X, Y unchanged.
    ;   Character displayed.  Screen scrolled if appropriate.

    pha
    and #$00FF
    jsr i_PlotGlyph
    jsr i_CursorRight
    pla
    rts
.endproc

.export tioSetXY
.proc tioSetXY
    jsr tioHideCursor
    jsr i_SetXY
    jmp tioShowCursor
.endproc
.proc i_SetXY
    ; Pre-conditions:
    ;   A = column
    ;   Y = row
    ;
    ; Post-conditions:
    ;   0 <= cx < right
    ;   0 <= cy < bottom

    pha

    sta cx
    sty cy

    lda #RIGHT-1
    cmp cx
    bcs cx_lt_right     ; right-1 >= cx
    sta cx
    ; cx = right-1

cx_lt_right:
    ; cx <= right-1
    ; cx < right
    ; 0 <= cx < right

    lda #BOTTOM-1
    cmp cy
    bcs cy_le_bottom    ; bottom-1 >= cy
    sta cy
    ; cy = bottom-1

cy_le_bottom:
    ; cy <= bottom-1
    ; cy < bottom
    ; 0 <= cy < bottom

    pla
    rts
.endproc

.proc i_CursorOffsetInBitmap
    ; Pre-conditions:
    ;   0 <= cx < right
    ;   0 <= cy < bottom
    ;   bitmap size < 65536 bytes
    ;
    ; post-conditions:
    ;   A = offset into bitmap corresponding to character position (cx,cy)
    ;   0 <= A < size of bitmap
    ;
    ; Note: I'm using a slow, but effective method for multiplication by
    ; repeated sums.  Since I do not anticipate a Y coordinate in excess
    ; of 59 very often, I think this is a reasonable tradeoff to make between
    ; getting the software out the door soon versus producing correct
    ; software.

    phy             ; S = [Y]

    ; 8*(cy * width) + cx < bitmap size

    lda #0          ; offset = 0
    ldy cy          ; Y >= 0
    bra L2
L1: clc             ; Y >= 1
    adc #640        ; offset = 8*n*width, 0 <= n < cy
    dey             ; Y >= 0
L2: bne L1          ; invariant: Y /= 0
    ; Y = 0
    ; offset = 8*(cy * width), offset < bitmap size
    ; offset + cx < bitmap size
    clc
    adc cx
    ; offset = 8*(width * cy) + cx, offset < bitmap size

    ply             ; S = []
    rts
.endproc

.export tioCursorRight
.proc tioCursorRight
    jsr tioHideCursor
    jsr i_CursorRight
    jmp tioShowCursor
.endproc
.proc i_CursorRight
    ; Pre-conditions:
    ;   0 <= cx < right
    ;   0 <= cy < bottom
    ;
    ; post-conditions:
    ;   0 <= cx < right
    ;   0 <= cx < bottom

    pha                     ; S = [A]
    lda cx
    inc
    cmp #RIGHT
    bcs cx_1_ge_right       ; (cx+1) >= right
                            ; (cx+1) < right
    sta cx                  ; cx = old cx + 1; 0 <= cx < right
    pla                     ; S = []
    rts

cx_1_ge_right:              ; S = [A], (cx+1) >= right
    stz cx                  ; cx = 0; 0 <= cx < right
    pla                     ; S = []
    jmp i_CursorDown
.endproc

.export tioCursorDown
.proc tioCursorDown
    jsr tioHideCursor
    jsr i_CursorDown
    jmp tioShowCursor
.endproc

.export tioCarriageReturn
.proc tioCarriageReturn
    jsr tioHideCursor
    jsr i_CarriageReturn
    jmp tioShowCursor
.endproc
.proc i_CarriageReturn
    ; pre-conditions:
    ;   0 <= cy < bottom
    ;
    ; post-conditions:
    ;   cx = left
    ;   0 <= cy < bottom
    ;   old cy <= cy <= old cy+1

    ; S = []
    pha
    ; S = [A]

    stz cx
    ; cx = left, S = [A]
    pla
    ; S = []
.endproc
    ; fall through
.proc i_CursorDown
    ; pre-conditions:
    ;   0 <= cy < bottom
    ;
    ; post-conditions:
    ;   0 <= old cy <= cy <= old cy + 1 < bottom

    ; S = []
    pha
    ; S = [A]

    ; 0 <= cy < bottom
    lda cy
    inc
    cmp #BOTTOM
    bcs cy_1_ge_bottom  ; (cy+1) >= bottom
    sta cy
    ; old cy <= cy <= old cy+1
    ; 0 <= cy < bottom
    pla
    ; S = []
    rts

cy_1_ge_bottom:
    ; S = [A]
    ; 0 <= cy < bottom
    ; cy+1 = bottom
    pla
    ; S = []
.endproc
    ; fall through again!
.proc i_VerticalScroll
    phb
    pha
    phx
    phy

    lda #37760              ; scroll the entire bitmap up.
    ldx #640                ; should be migrated into graphics.a
    ldy #0
    mvn $FE, $FE

    ldx #37760              ; Clear bottom line of the screen
    lda #0                  ; should also be in graphics.a
    sta 0,x
    ldy #37761
    lda #640
    mvn $FE, $FE

    ply
    plx
    pla
    plb
    rts
.endproc
.proc i_PlotGlyph
    ; Preconditions:
    ;   0 <= A < 256; A = character to display
    ;   _font points to a 2048 x 8 bitmap containing character glyphs.

    pha
    phx
    phy
    phd

    ; S = [D, Y, X, A]

    pea $00FE
    jsr i_CursorOffsetInBitmap
    pha

    ; S = [p, D, Y, X, A]

    lda _font+2
    pha
    lda _font
    clc
    adc 13,s    ; use character specified in A on entry
    pha

    tsc
    tcd

    ; S = [g, p, D, Y, X, A ]

p   =   5       ; bitmap pointer
g   =   1       ; glyph pointer

    ldx #8
    ldy #0

L1: ; invariant: X >= 1
    ;   y = 0
    ;   _font <= g < (_font + 2048)
    ;   _frame <= p < (_frame + size of bitmap)

    AX8
    lda [g],y
    sta [p],y
    AX16

    ;   ((X-1 > 0) & (g+256 < (_font + 2048))) | ((X-1 = 0) & (g+256 >= (_font + 2048)))
    inc g+1
    ;   ((X-1 > 0) & (g < (_font + 2048))) | ((X-1 = 0) & (g >= (_font + 2048)))

    ;   (p + _width) < (_frame + size of bitmap)
    clc
    lda #RIGHT
    adc p
    sta p
    ;   p < (_frame + size of bitmap)

    ;   ((X-1 > 0) & (g < (_font + 2048))) | ((X-1 = 0) & (g >= (_font + 2048)))
    dex 
    ;   ((X > 0) & (g < (_font + 2048))) | ((X = 0) & (g >= (_font + 2048)))
    bne L1
    ; X = 0 & g >= (_font + 2048) & S = [g, p, D, Y, X, A]

    ; S = [g, p, D, Y, X, A]
    tsc
    clc
    adc #8
    tcs
    ; S = [D, Y, X, A]

    pld
    ply
    plx
    pla
    rts
.endproc

.export tioShowCursor
.proc tioShowCursor
    ; Decrements the hide-count for the cursor.  If non-zero, the cursor is
    ; not visible to the user.  Otherwise, the cursor will be rendered.
    ;
    ; pre-conditions:
    ;   0 <= hidden <= 65535
    ;
    ; post-conditions:
    ;   0 <= hidden <= old hidden <= 65535

    pha
    lda hidden
    beq alreadyZero     ; 0 = hidden
    ; 0 < hidden
    ; 0 <= hidden-1
    dec
    ; 0 <= hidden
    sta hidden
alreadyZero:
    ; 0 <= hidden

    jsr tioDrawCursor
    pla
    rts
.endproc

.export tioHideCursor
.proc tioHideCursor
    ; Increments the hide-count for the cursor.
    ;
    ; pre-conditions:
    ;   0 <= hidden <= 65535
    ;
    ; post-conditions:
    ;   0 <= old hidden <= hidden <= 65535

    pha
    lda hidden
    cmp #-1
    beq alreadyMaxedOut     ; hidden = 65535
    ; hidden+1 <= 65535
    inc
    ; hidden <= 65535
    sta hidden
alreadyMaxedOut:
    ; hidden <= 65535
    jsr tioEraseCursor
    pla
    rts
.endproc

.export tioToggleCursor
.proc tioToggleCursor
    ; If the cursor is visible, alternate between (in)visible
    ; states, giving the illusion of a blinking cursor over time.

    pha
    lda #0
    jsr i_AffectCursor
    pla
    rts
.endproc

.export tioDrawCursor
.proc tioDrawCursor
    ; Guarantee the cursor is drawn on the screen.

    pha
    lda #8
    jsr i_AffectCursor
    pla
    rts
.endproc

.export tioEraseCursor
.proc tioEraseCursor
    pha
    lda #16
    jsr i_AffectCursor
    pla
    rts
.endproc

.proc i_AffectCursor
    ; pre-conditions:
    ;   A[2:0] = 0
    ;   A[4:3] = operation sub-table ID (00 = toggle, 01 = draw, 10 = erase)

    ; S = []
    phx
    ; S = [X]

    ; A[2] = 0
    ldx cursorIsDrawn
    beq cursorIsErased
    ora #$04
cursorIsErased:
    ; A[2] = 1 if cursor is current drawn on the screen

    ; A[1] = 0
    ldx hidden
    beq cursorIsVisible
    ora #$02
cursorIsVisible:
    ; A[1] = 1 if cursor is hidden from the user

    ; A[4:3] = command ID
    ; A[2] = 1 if cursor is currently drawn on the screen
    ; A[1] = 1 if cursor is hidden from the user (see tioShowCursor, et. al.)
    ; A[0] = 0
    tax
    jmp (J,x)
    ;       +--------------------------  visible and erased
    ;       |      +-------------------  hidden and erased
    ;       |      |       +-----------  visible and drawn
    ;       |      |       |       +---  hidden and drawn
    ;       |      |       |       |
J:  .word _draw, _noop, _erase, _erase      ; toggle actions
    .word _draw, _noop, _noop,  _noop       ; draw actions
    .word _noop, _noop, _erase, _erase      ; erase actions

_draw:
    lda #-1
    sta cursorIsDrawn
    jsr i_XORCursor
    ; S = [X]
    plx
    rts

_erase:
    stz cursorIsDrawn
    jsr i_XORCursor

_noop:
    ; S = [X]
    plx
    rts

.endproc

.proc i_XORCursor
    pha
    phx
    phy
    phd
    ; S = [D,Y,X,A]

    pea $00FE
    jsr i_CursorOffsetInBitmap
    pha
    ; S = [p,D,Y,X,A]

    tsc
    tcd

    ldy #0
    ldx #8
L:  lda [1],y
    eor #$FF
    sta [1],y
    tya
    clc
    adc #80
    tay
    dex
    bne L

    ; S = [p, D, Y, X, A]
    plx
    plx
    ; S = [D,Y,X,A]
    pld
    ply
    plx
    pla
    rts
.endproc

.export tioClear
.proc tioClear
    jsr tioHideCursor
    jsr i_Clear
    jmp tioShowCursor
.endproc

.proc i_Clear
    pha
    phb
    lda #0
    sta $FE0000
    tax
    lda #38400
    ldy #1
    mvn $FE, $FE
    plb
    pla
    rts
.endproc

.export tioHome
.proc tioHome
    pha
    phy
    lda #0
    tay
    jsr tioSetXY
    ply
    pla
    rts
.endproc

.export tioTypeString
.proc tioTypeString
    jsr tioHideCursor
    jsr i_TypeString
    jmp tioShowCursor
.endproc

.proc i_TypeString
    ; Preconditions:
    ;   X = address of the string to print
    ;   Y = number of characters to print
    ;
    ;   Note that character codes like $0D (carriage return) or $0A
    ;   (line feed) are NOT INTERPRETED by this routine.
    ;
    ; Postconditions:
    ;   All register values preserved.

    pha
    phx
    phy

L:  lda 0,x
    and #$00FF
    jsr i_TypeCharacter
    inx
    dey
    bne L

    ply
    plx
    pla
    rts
.endproc

.export tioRawKeyEvent
.proc tioRawKeyEvent
    ; Pre-conditions:
    ;   Called from inside interrupt handler or similar keyboard-related
    ;   driver service.
    ;
    ;   A = raw key scancode
    ;
    ; Post-conditions:
    ;   tioGetKey guaranteed not to block.
    ;   tioGetKey would return raw scancode.

    inc rawKeyEvents
    sta lastKeyPressed
    rts
.endproc

.export tioGetKey
.proc tioGetKey
    ; Pre-conditions:
    ;   An interrupt handler installed to watch over keyboard events.
    ;   It must invoke tioRawKeyEvent when a keyboard press is detected.
    ;   Interrupts enabled.
    ;
    ; Post-conditions without keyboard interrupt handler OR interrupts disabled:
    ;   Deadlock.
    ;
    ; Post-conditions with interrupt handler:
    ;   Blocks until a raw keyboard scancode becomes available.
    ;   A = key code retrieved.

L:  lda rawKeyEvents
    beq L
    php
    sei
    lda lastKeyPressed
    stz rawKeyEvents
    plp
    rts
.endproc

.export tioTypeHex16
.proc tioTypeHex16
    ; Pre-conditions:
    ;   A[0:15] = value to print
    ;
    ; Post-conditions:
    ;   X, Y preserved.  Text displayed on screen with cursor updated.
    ;   A = last ASCII character printed

    pha
    xba
    jsr tioTypeHex8
    pla
.endproc
.export tioTypeHex8
.proc tioTypeHex8
    ; Pre-conditions:
    ;   A[0:7] = value to print
    ;
    ; Post-conditions:
    ;   X, Y preserved.  Text displayed on screen with cursor updated.
    ;   A = last ASCII character printed

    pha
    lsr
    lsr
    lsr
    lsr
    jsr tioTypeHex4
    pla
.endproc
.proc tioTypeHex4
    ; Pre-conditions:
    ;   A[0:3] = value to print
    ;
    ; Post-conditions:
    ;   X, Y preserved.  Text displayed on screen with cursor updated.
    ;   A = ASCII character corresponding to the nybble printed.

    phx
    and #$000F
    tax
    lda hextable,x
    plx
    jmp tioTypeCharacter

hextable:
    .byte "0123456789ABCDEF"
.endproc

