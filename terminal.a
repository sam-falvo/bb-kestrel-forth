    .p816
    .a16
    .i16


    .include "hw/cpu.inc"


;
; Emulates a dumb teletype.
;
; Footnote:
; It amazes me that we are still emulating -teletypes-.  Commodore has gone
; the furthest in advancing the state of the art in textual user interfaces
; by implementing a crude text editor as their basic UI.  At some point in
; the future, I will revisit this idea; it's what I strove for in the orig-
; inal Kestrel-2 ROMs, but never fully realized.
;
; Some day...
;


    .rodata

romFont:
    .incbin "font.bin"


    .bss

    ; The current (x,y) cursor position.
cx:     .res 2      ; invariant: 0 <= x < right
cy:     .res 2      ; invariant: 0 <= y < bottom

    ; Non-zero if the cursor is obscured from the screen.
hidden: .res 2      ; invariant: 0 <= hidden <= 65535

    ; Non-zero if the cursor is physically rendered to the screen.
cursorIsDrawn: .res 2


RIGHT   = 80
BOTTOM  = 60

_font:  .res 4
    ; pointer to a 2048x8 pixel bitmap containing the font to draw with.
    ; All glyphs are 8x8 pixels in size.

_frame: .res 4
    ; pointer to the current bitmap.


    .code

.export tioInitialize
.proc tioInitialize
    pha
    stz cx
    stz cy
    stz hidden
    lda #romFont
    sta _font
    stz _font+2
    stz _frame
    lda #$FE
    sta _frame+2
    pla
    rts
.endproc


.export tioTypeCharacter
.proc tioTypeCharacter
    ; Prints a single character to the screen.
    ;
    ; Preconditions:
    ;   A[7:0] = character to plot
    ;   A[15:8] ignored.
    ;
    ;   Framebuffer established using _wide, _setFramebuffer, et. al.
    ;   Cursor window established: see _setWindowOrigin, _setWindowExtent.
    ;   Cursor position previously established; see _setXY.
    ;
    ; Post-conditions:
    ;   A, X, Y unchanged.
    ;   Character displayed.  Screen scrolled if appropriate.

    pha
    and #$00FF
    jsr plotGlyph
    jsr tioCursorRight
    pla
    rts
.endproc

.export tioSetXY
.proc tioSetXY
    ; Pre-conditions:
    ;   A = column
    ;   Y = row
    ;
    ; Post-conditions:
    ;   0 <= cx < right
    ;   0 <= cy < bottom

    pha

    sta cx
    sty cy

    lda #RIGHT-1
    cmp cx
    bcs cx_lt_right     ; right-1 >= cx
    sta cx
    ; cx = right-1

cx_lt_right:
    ; cx <= right-1
    ; cx < right
    ; 0 <= cx < right

    lda #BOTTOM-1
    cmp cy
    bcs cy_le_bottom    ; bottom-1 >= cy
    sta cy
    ; cy = bottom-1

cy_le_bottom:
    ; cy <= bottom-1
    ; cy < bottom
    ; 0 <= cy < bottom

    pla
    rts
.endproc

.proc cursorOffsetInBitmap
    ; Pre-conditions:
    ;   0 <= cx < right
    ;   0 <= cy < bottom
    ;   bitmap size < 65536 bytes
    ;
    ; post-conditions:
    ;   A = offset into bitmap corresponding to character position (cx,cy)
    ;   0 <= A < size of bitmap
    ;
    ; Note: I'm using a slow, but effective method for multiplication by
    ; repeated sums.  Since I do not anticipate a Y coordinate in excess
    ; of 59 very often, I think this is a reasonable tradeoff to make between
    ; getting the software out the door soon versus producing correct
    ; software.

    phy             ; S = [Y]

    ; 8*(cy * width) + cx < bitmap size

    lda #0          ; offset = 0
    ldy cy          ; Y >= 0
    bra L2
L1: clc             ; Y >= 1
    adc #640        ; offset = 8*n*width, 0 <= n < cy
    dey             ; Y >= 0
L2: bne L1          ; invariant: Y /= 0
    ; Y = 0
    ; offset = 8*(cy * width), offset < bitmap size
    ; offset + cx < bitmap size
    clc
    adc cx
    ; offset = 8*(width * cy) + cx, offset < bitmap size

    ply             ; S = []
    rts
.endproc

.export tioCursorRight
.proc tioCursorRight
    ; Pre-conditions:
    ;   0 <= cx < right
    ;   0 <= cy < bottom
    ;
    ; post-conditions:
    ;   0 <= cx < right
    ;   0 <= cx < bottom

    pha                     ; S = [A]
    lda cx
    inc
    cmp #RIGHT
    bcs cx_1_ge_right       ; (cx+1) >= right
                            ; (cx+1) < right
    sta cx                  ; cx = old cx + 1; 0 <= cx < right
    pla                     ; S = []
    rts

cx_1_ge_right:              ; S = [A], (cx+1) >= right
    stz cx                  ; cx = 0; 0 <= cx < right
    pla                     ; S = []
    jmp tioCursorDown
.endproc

.export tioCarriageReturn
.proc tioCarriageReturn
    ; pre-conditions:
    ;   0 <= cy < bottom
    ;
    ; post-conditions:
    ;   cx = left
    ;   0 <= cy < bottom
    ;   old cy <= cy <= old cy+1

    ; S = []
    pha
    ; S = [A]

    stz cx
    ; cx = left, S = [A]
    pla
    ; S = []
.endproc
    ; fall through
.export tioCursorDown
.proc tioCursorDown
    ; pre-conditions:
    ;   0 <= cy < bottom
    ;
    ; post-conditions:
    ;   0 <= old cy <= cy <= old cy + 1 < bottom

    ; S = []
    pha
    ; S = [A]

    ; 0 <= cy < bottom
    lda cy
    inc
    cmp #BOTTOM
    bcs cy_1_ge_bottom  ; (cy+1) >= bottom
    sta cy
    ; old cy <= cy <= old cy+1
    ; 0 <= cy < bottom
    pla
    ; S = []
    rts

cy_1_ge_bottom:
    ; S = [A]
    ; 0 <= cy < bottom
    ; cy+1 = bottom
    pla
    ; S = []
.endproc
    ; fall through again!
.proc verticalScroll
    phb
    pha
    phx
    phy

    lda #37760              ; scroll the entire bitmap up.
    ldx #640                ; should be migrated into graphics.a
    ldy #0
    mvn $FE, $FE

    ldx #37760              ; Clear bottom line of the screen
    lda #0                  ; should also be in graphics.a
    sta 0,x
    ldy #37761
    lda #640
    mvn $FE, $FE

    ply
    plx
    pla
    plb
    rts
.endproc

.proc plotGlyph
    ; Preconditions:
    ;   0 <= A < 256; A = character to display
    ;   _frame points to a valid framebuffer or suitably sized bitmap.
    ;   _font points to a 2048 x 8 bitmap containing character glyphs.

    pha
    phx
    phy
    phd

    ; S = [D, Y, X, A]

    lda _frame+2
    pha
    lda _frame
    pha

    jsr cursorOffsetInBitmap
    clc
    adc 1,s
    sta 1,s
    lda #0
    adc 3,s
    sta 3,s

    ; S = [p, D, Y, X, A]

    lda _font+2
    pha
    lda _font
    clc
    adc 13,s    ; use character specified in A on entry
    pha

    tsc
    tcd

    ; S = [g, p, D, Y, X, A ]

p   =   5       ; bitmap pointer
g   =   1       ; glyph pointer

    ldx #8
    ldy #0

L1: ; invariant: X >= 1
    ;   y = 0
    ;   _font <= g < (_font + 2048)
    ;   _frame <= p < (_frame + size of bitmap)

    AX8
    lda [g],y
    sta [p],y
    AX16

    ;   ((X-1 > 0) & (g+256 < (_font + 2048))) | ((X-1 = 0) & (g+256 >= (_font + 2048)))
    inc g+1
    ;   ((X-1 > 0) & (g < (_font + 2048))) | ((X-1 = 0) & (g >= (_font + 2048)))

    ;   (p + _width) < (_frame + size of bitmap)
    clc
    lda #RIGHT
    adc p
    sta p
    ;   p < (_frame + size of bitmap)

    ;   ((X-1 > 0) & (g < (_font + 2048))) | ((X-1 = 0) & (g >= (_font + 2048)))
    dex 
    ;   ((X > 0) & (g < (_font + 2048))) | ((X = 0) & (g >= (_font + 2048)))
    bne L1
    ; X = 0 & g >= (_font + 2048) & S = [g, p, D, Y, X, A]

    ; S = [g, p, D, Y, X, A]
    tsc
    clc
    adc #8
    tcs
    ; S = [D, Y, X, A]

    pld
    ply
    plx
    pla
    rts
.endproc

.export tioShowCursor
.proc tioShowCursor
    ; Decrements the hide-count for the cursor.  If non-zero, the cursor is
    ; not visible to the user.  Otherwise, the cursor will be rendered.
    ;
    ; pre-conditions:
    ;   0 <= hidden <= 65535
    ;
    ; post-conditions:
    ;   0 <= hidden <= old hidden <= 65535

    pha
    lda hidden
    beq alreadyZero     ; 0 = hidden
    ; 0 < hidden
    ; 0 <= hidden-1
    dec
    ; 0 <= hidden
    sta hidden
alreadyZero:
    ; 0 <= hidden
    pla
    rts
.endproc

.export tioHideCursor
.proc tioHideCursor
    ; Increments the hide-count for the cursor.
    ;
    ; pre-conditions:
    ;   0 <= hidden <= 65535
    ;
    ; post-conditions:
    ;   0 <= old hidden <= hidden <= 65535

    pha
    lda hidden
    cmp #-1
    beq alreadyMaxedOut     ; hidden = 65535
    ; hidden+1 <= 65535
    inc
    ; hidden <= 65535
    sta hidden
alreadyMaxedOut:
    ; hidden <= 65535
    pla
    rts
.endproc

.export tioToggleCursor
.proc tioToggleCursor
    ; If the cursor is visible, alternate between (in)visible
    ; states, giving the illusion of a blinking cursor over time.

    pha
    lda #0
    jsr affectCursor
    pla
    rts
.endproc

.export tioDrawCursor
.proc tioDrawCursor
    ; Guarantee the cursor is drawn on the screen.

    pha
    lda #8
    jsr affectCursor
    pla
    rts
.endproc

.export tioEraseCursor
.proc tioEraseCursor
    pha
    lda #16
    jsr affectCursor
    pla
    rts
.endproc

.proc affectCursor
    ; pre-conditions:
    ;   A[2:0] = 0
    ;   A[4:3] = operation sub-table ID (00 = toggle, 01 = draw, 10 = erase)

    ; S = []
    phx
    ; S = [X]

    ; A[2] = 0
    ldx cursorIsDrawn
    beq cursorIsErased
    ora #$04
cursorIsErased:
    ; A[2] = 1 if cursor is current drawn on the screen

    ; A[1] = 0
    ldx hidden
    beq cursorIsVisible
    ora #$02
cursorIsVisible:
    ; A[1] = 1 if cursor is hidden from the user

    ; A[4:3] = command ID
    ; A[2] = 1 if cursor is currently drawn on the screen
    ; A[1] = 1 if cursor is hidden from the user (see tioShowCursor, et. al.)
    ; A[0] = 0
    tax
    jmp (J,x)
    ;       +--------------------------  visible and erased
    ;       |      +-------------------  hidden and erased
    ;       |      |       +-----------  visible and drawn
    ;       |      |       |       +---  hidden and drawn
    ;       |      |       |       |
J:  .word _draw, _noop, _erase, _erase      ; toggle actions
    .word _draw, _noop, _noop,  _noop       ; draw actions
    .word _noop, _noop, _erase, _erase      ; erase actions

_draw:
    lda #-1
    sta cursorIsDrawn
    jsr tioXORCursor
    ; S = [X]
    plx
    rts

_erase:
    stz cursorIsDrawn
    jsr tioXORCursor

_noop:
    ; S = [X]
    plx
    rts

.endproc

.proc tioXORCursor
    pha
    phx
    phy
    phd
    ; S = [D,Y,X,A]

    lda _frame+2
    pha
    lda _frame
    pha

    jsr cursorOffsetInBitmap
    clc
    adc 1,s
    sta 1,s
    lda 3,s
    adc #0
    sta 3,s
    tsc
    tcd

    ldy #0
    ldx #8
L:  lda [1],y
    eor #$FF
    sta [1],y
    tya
    clc
    adc #80
    tay
    dex
    bne L

    ; S = [p, D, Y, X, A]
    plx
    plx
    ; S = [D,Y,X,A]
    pld
    ply
    plx
    pla
    rts
.endproc

